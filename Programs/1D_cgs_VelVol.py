from math import *	# You don't have to add "math" before any modules of 
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

## Ref. Torrejon, Tunable inertia of chiral magnetic domain walls
## Ref. Martinez, Current-driven dynamics of Dzyaloshinskii domain walls in the presence of in-plane field
## Ref. Martinez, Coupled Dzyaloshinskii walls and their current-induced dynamics by the spin Hall effect
## y[0] is q (DW position), y[1] is psi (angle of moment in DW), y[2] is chi (angle of DW).
## 1e+04 below is to avoid errors. We have to erase that conversion coefficient later.
def one_dim_model_3var(y, t_0, Alpha, Gamma, Delta, Width, DWtype, H_K, H_DM, H_SH, K_eff, M_s, T_FM, V_0, Period):
	return \
	np.array([\
	1e+04 * (-Gamma * H_K * sin(2 * (y[1] - y[2])) / 2 + DWtype * pi * Gamma * H_DM * sin(y[1] - y[2]) / 2 + Alpha * Gamma * (H_PIN(y[0], M_s, Width, T_FM, V_0, Period) + H_th(Alpha, Temperature, M_s, Delta, T_FM, Width)) + Alpha * DWtype * pi * Gamma * H_SH * cos(y[1]) / 2) * Delta / (cos(y[2]) * (1 + Alpha ** 2)),\
	(Alpha * Gamma * H_K * sin(2 * (y[1] - y[2])) / 2 - Alpha * pi * DWtype * Gamma * H_DM * sin(y[1] - y[2]) / 2 + Gamma * (H_PIN(y[0], M_s, Width, T_FM, V_0, Period) + H_th(Alpha, Temperature, M_s, Delta, T_FM, Width)) + DWtype * pi * Gamma * H_SH * cos(y[1]) / 2) / (1 + Alpha ** 2),\
	(- H_K * sin(2 * (y[1] - y[2])) / 2 + DWtype * pi * H_DM * sin(y[1] - y[2]) / 2 - 2 * K_eff * tan(y[2]) / M_s + DWtype * pi * H_DM * cos(y[1] - y[2]) * tan(y[2]) / 2 - H_K * cos(y[1] - y[2])**2 * tan(y[2])) * 12 * Gamma / (Alpha * pi**2 * (tan(y[2])**2 + (Width / (pi * Delta * cos(y[2])))**2))\
	])

def H_K(T_FM, M_s, Delta):	# anisotropy field
	return 4 * T_FM * M_s * log(2) / Delta

def H_DM(D, DWtype, Delta, M_s):	# DM field
	return D * DWtype / (Delta * M_s)

def H_SH(Theta_SH, Current, M_s, T_FM):	# field generated by spin current
	return - Hbar * Theta_SH * Current / (2 * Charge * M_s * T_FM)

def H_PIN(q, M_s, Width, T_FM, V_0, Period):	# pinning field
	# Ref. Martinez, Coupled Dzyaloshinkii walls and their current-induced dynamics by the spin Hall effect
	# H_pin = - (1 / 2 Mu_0 M_s L_y L_z) dV_pin / dx
	# L_y = Width, L_z = T_FM, V_pin is a pinning potential.
	# Here I use V_pin (x) = V_0 sin(pi x / p)^2,
	# V_0 = 20 * 10^(-21) J = 20 * 10^(-14) erg, p = 21nm = 21 * 10^(-7) cm.
	# So in the cgs unit, H_pin = - (pi V_0 / p M_s Width T_FM) sin(pi x / p) cos(pi x / p)
	return 0
	#return - (pi * V_0 / (Period * M_s * Width * T_FM)) * sin(pi * q / Period) * cos (pi * q / Period)

def H_th(Alpha, Temperature, M_s, Delta, T_FM, Width):	# thermal field
	#return np.random.normal(0, sqrt(2 * Alpha * K_B * Temperature / (Gamma * M_s * Delta * Width * T_FM)))	
	return 0

def D(Current):	# DMI constant depending on spin current. erg/cm^2
	#return 0.24 + Current * 1e-09
	return 0.24
	
print ("flag 10")

## Physical constants
Hbar = 1.0545718e-27	# Dirac constant. erg*s.
Charge = 1.60217662e-19	# elementary charge. Unit:C.
Gamma = 1.7608598e+07	# gyromagnetic ratio. rad/sG
K_B = 1.380649e-16	# Boltzmann constant. erg/K.
#Mu_0 = 4 * pi * 1e-07	# magnetic permiability. H/m.

Temperature = 300	# ambient temperature
Seed = 213	# seed of Mersenne twister

## Consider W / 1 CoFeB / 2 MgO / 1 Ta.
K_eff = 3.2e+06	# effective magnetic anisotropy enery. erg/cm^3.
M_s = 1100	# saturation magnetization. emu/cm^3.
Alpha = 0.01	# damping coefficient
DWtype = 1	# this means up/down DW. -1 if down/up DW.
Exchange = 1.5e-06	# exchange stiffness. erg/cm.
Delta = sqrt(Exchange / K_eff)	# width of DW.
Width = 5.0e-04	# width of wire. 5um.
T_FM = 1.0e-07	# thickness of CoFeB. 1nm.
#D = 0.24	# DMI constant. erg/cm^2
Theta_SH = -0.21	# spin Hall angle.
#Voltage = 25 # voltage. 25V.
#Rho_W = # resistivity of W. Ohm*m.
#Rho_Ta = # resistivity of Ta.
#T_W = 1.0e-07	# thickness of W. 1nm.
#T_Ta = 0.0e-07	# thickness of Ta. 0nm.
#Length = 30e-04	# length of wire
#V_0 = 20e-14	# pinning amplitude. erg.
V_0 = 20e-09
Period = 21e-03	# pinning periodicity. 21nm. cm. But q's unit is um for accuracy of numerical calculation. So, this should be um too.

np.random.seed(Seed)	# set seed for Mersenne twister

#Current = 0.5e+08	# current density in heavy metal layer Ta / W. A/cm^2.
Current_start = -0.2e+08
Current_end = 0.2e+08
Current_step = 0.001e+08
Current = np.arange(Current_start, Current_end, Current_step, dtype = np.float64)	# current density in heavy metal layer Ta / W. A/cm^2.
velocity_eff = np.zeros(Current.size) 
velocity_stat = np.zeros(Current.size)
#print (Current)

## time array
Duration = 100e-09	# current pulse duration. 100ns.
T_step = 1e-12	# time step when we get the results, not a time step of numerical calculation.
t_1 = np.arange(0, Duration, T_step, dtype = np.float64)	# time array when solutions are obtained.
## after switch of the current
T_end = 300e-09	# final time. 300ns.
t_2 = np.arange(Duration, T_end, T_step, dtype = np.float64)

print ("flag 20")

i = 0
for J in Current:
	# initial condition
	y_0 = np.array([0.0, 0.0, 0.0])
	print ("flag 30")
	## solve the equation
	y_1 = odeint(one_dim_model_3var, y_0, t_1, args = (Alpha, Gamma, Delta, Width, DWtype, H_K(T_FM, M_s, Delta), H_DM(D(J), DWtype, Delta, M_s), H_SH(Theta_SH, J, M_s, T_FM), K_eff, M_s, T_FM, V_0, Period))
	
	print ("flag 40")
	y_0 = y_1[-1]	# the initial condition is the final state of the previous calculation.
	y_2 = odeint(one_dim_model_3var, y_0, t_2, args = (Alpha, Gamma, Delta, Width, DWtype, H_K(T_FM, M_s, Delta), H_DM(D(0), DWtype, Delta, M_s), H_SH(Theta_SH, 0, M_s, T_FM), K_eff, M_s, T_FM, V_0, Period))
	
	print("flag 50")
	velocity_eff[i] = (y_2[-1, 0] / Duration) * 1e-06	# 1e-06 is conversion of um/s into m/s
	velocity_stat[i] = (y_1[-1, 0] / Duration) * 1e-06	
	print (i, "-th calculation finished.")
	i += 1

## plot velocity
plt.figure(1)
plt.scatter(Current[:], velocity_eff[:], label = "effective")
plt.scatter(Current[:], velocity_stat[:], label = "stationary")
plt.xlabel("Current density [A/cm$^2$]")
plt.ylabel("Velocity [m/s]")
plt.legend()
plt.grid(True)

## plot velocity ration
ratio = velocity_eff / velocity_stat
plt.figure(2)
plt.scatter(Current[:], ratio[:], label = "velocity ratio")
plt.xlabel("Current density [A/cm$^2$]")
plt.ylabel("Velocity Ratio")
plt.legend()
plt.grid(True)

plt.show()



# combine the two results.
#t = np.r_[t_1, t_2]	# np.r_ combines two arrays in the row direction.
#y = np.r_[y_1, y_2]
#v = np.gradient((y[:, 0] / 1e+04 / (T_end_1 / T_div_1)).flatten())
# np.flatten() returns a one-dimenstional array by flattening the input array.
# np.gradient calculates derivatives.
# np.gradient(y) means dy, and (T_end_1 / T_div_1) means dt. Then, v = dy/dt. 1e+04 comes from unit conversion.
#print (v)

## plot position
#plt.figure(4)
#plt.scatter(t * 1e+09, y[:, 0])
#plt.xlabel("Time [ns]")
#plt.ylabel("Position [$\mu$m]")
#plt.grid(True)

## plot velocity
#plt.figure(1)
#plt.scatter(t * 1e+09, v[:])
#plt.xlabel("Time [ns]")
#plt.ylabel("Velocity [m/s]")
#plt.grid(True)

## plot moment angle
#plt.figure(2)
#plt.scatter(t * 1e+09, y[:, 1] * 180 / pi)
#plt.grid(True)
#plt.xlabel("Time [ns]")
#plt.ylabel("Moment angle [degree]")

## plot DW angle
#plt.figure(3)
#plt.scatter(t * 1e+09, y[:, 2] * 180 / pi)
#plt.xlabel("Time [ns]")
#plt.ylabel("DW angle [degree]")
#plt.grid(True)

#plt.show()

